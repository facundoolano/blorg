---
title: Getting started with Go (and Emacs)
date: 2024-03-01 18:22:47
layout: post
lang: en
tags: [golang, emacs]
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

Dumping some notes I took while I was setting up my environment and reading the bare minimum to get started with Go, before jumping into the project.

*** Go setup
- I'm on Mac and I had some older version of Go already installed, so I had to ~brew uninstall go~.
- Go 1.22 had recently come out, and it wasn't yet available in brew, so I [[https://go.dev/doc/install][downloaded it]] from the Go website.
- I had to add this to my ~~/.zshrc~ for everything to work ([[https://stackoverflow.com/a/57217841/993769][source]]):
  #+begin_src zsh
export GOPATH=$HOME/go
export GOROOT=/usr/local/go
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOPATH
export PATH=$PATH:$GOROOT/bin
export PATH=$PATH:$GOPATH/bin
  #+end_src

*** Emacs setup
In the last couple of years the Emacs LSP integration has got good enough that, other things being equal, I tend to prefer it when I'm setting up a new language since it provides a similar out-of-the-box experience to the one I have for other languages, without requiring much configuration. A quick search for recent Go+Emacs setup suggestions didn't yield a definite answer, but I did see a few people using [[https://github.com/dominikh/go-mode.el][go-mode]] together with LSP, so I went with that.

- ~go install golang.org/x/tools/gopls@latest~ to install [[https://github.com/golang/tools/tree/master/gopls][gopls]], the Go server the lsp-mode expects.
- ~go install honnef.co/go/tools/cmd/staticcheck@latest~ for the [[https://staticcheck.dev/][staticcheck linter]].

This is what my relevant config ended up looking:
#+begin_src elisp
(require 'go-mode)
(require 'lsp-mode)

(add-hook 'go-mode-hook 'lsp-deferred)
(add-hook 'go-mode-hook 'subword-mode)
(add-hook 'before-save-hook 'gofmt-before-save)

(add-hook 'go-mode-hook (lambda ()
                          (setq tab-width 4)
                          (flycheck-add-next-checker 'lsp 'go-vet)
                          (flycheck-add-next-checker 'lsp 'go-staticcheck)))
#+end_src

The only issues I've found so far:

- ~lsp-describe-thing-at-point~ does give me documentation, but it only includes the first sentence of the doc comment, not the entire paragraph. I end up using ~xref-find-definitions~ to read it directly from the code.
- flycheck's ~next-error~ doesn't seem to work consistently in my Go setup as it does in other languages.

*** GitHub setup

- I started with a default GitHub Actions [[https://github.com/facundoolano/jorge/blob/adb17ad9d2cb1e9929e9f9066941ccf3ac13222a/.github/workflows/test.yml][workflow to run unit tests]], which I later extended to also run linters.
- I eventually wrote [[https://github.com/facundoolano/jorge/blob/adb17ad9d2cb1e9929e9f9066941ccf3ac13222a/.github/workflows/release.yml][another workflow]] to draft a release and upload binaries for all platforms when I pushed a git tag.

*** Go documentation
I had read [[https://www.openmymind.net/The-Little-Go-Book/][/The Little Go Book/]] a few years ago. And while I didn't do anything with what I read there and thus forgot most of it, I did remember that there wasn't anything surprising or complicated enough to require dedicated training.

I took a look a Go's [[https://go.dev/learn/][learn]] and [[https://go.dev/doc/][docs]] pages, but they didn't point me in a single obvious direction. There was the [[https://go.dev/doc/effective_go][/Effective Go/ book]], which sounded like the kind of resource I prefer to get familiar with new tech: text form, not very long, by the language authors. But this one started with a note saying it was written in 2009 and hasn't been updated significantly since, which made it unappealing for my short-term goals. I may revisit it eventually, though, since I understand it was the canonical learning source for many years and is a good showcase of Go's design philosophy.

I tried with the tutorials instead, but after a first /hello world/ one they quickly get into the weeds of modules and workspaces without enough context for them to be useful as learning resources (they actually side-tracked me to read more about [[https://go.dev/doc/modules/managing-source][modules]] and [[https://go.dev/doc/modules/layout][project layout]], trying to figure out how Go fits into what I knew from other languages).

What ended up working for me was starting my project from a /hello world/ program, looking up what I didn't know how to do in [[https://gobyexample.com/][Go by Example]] (which had at least partial answers for most of my questions) then jumping to the [[https://pkg.go.dev/][package documentation]] for details.

I'm sure I'm missing out on language features and idioms, but it was amazing that it took me about a day to go from installing Go to working steadily in my project.
I took note of some resources I could go back to take a deeper dive into the language, once I'm done with this project:

- Read each [[https://gobyexample.com/][/Go by Example/]] entry.
- Go back to [[https://go.dev/doc/effective_go][/Effective Go/]].
- Read the language gotchas from [[https://golang50shad.es/][/50 Shades of Go]]/.
- Consider reading the /100 Go Mistakes/ [[https://100go.co/book/][book]] or its online [[https://100go.co/][summary]].
- Consider skimming through the [[https://go.dev/ref/spec][language specification]].

I will elaborate on my first impressions of the language in a later post.
