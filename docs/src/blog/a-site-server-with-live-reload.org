---
title: A site server with live reload
date: 2024-03-05
layout: post
lang: en
tags: [golang, project]
draft: true
---
#+OPTIONS: toc:nil num:1
#+LANGUAGE: en

** Introduction

The core of the static site generator is the ~build~ command: take some input files, process them ---render templates, convert other markup formats into HTML--- and write the output for serving to the web. <This is where I started with ~jorge~, not only because it was the fundamental feature but because I needed to see the org-mode parsing output as early as possible to know whether I could reasonably expect this project to ultimately replace my Jekyll + org-export setup.

Although you could say that I had a working static site generator as soon I had the ~build~ command, for it to be minimally useful I needed some facility to preview a site while working on it: a ~serve~ command. It could be as simple as running local file server of the ~build~ output files, but ideally I would make it watch for changes and live reload the browser tabs looking at them.

I was aiming for more than the basics here because ~serve~ was the only non-trivial command I had planned for: the one with the most potential to learn other Go features ---and the most fun. For similar reasons I wanted to tackle it as early as possible: since it wasn't immediately obvious how I would implement it, it was here where unknown-unknowns and blockers were most likely to come up.
I knew it was a feasible feature because other generators have it, but I didn't want to just copy whatever Hugo or gojekyll were doing, I wanted to figure it out for myself.

The beauty of the ~serve~ command was that I could start with the most naive implementation and iterate towards the ideal one, keeping a usable command at every step. With ~build~ and ~serve~ out of the way, I'd be almost done with the project, the rest being nice to have features and UX improvements.

** Implementation

*** A basic file server

- basic fs server implementaion
#+begin_src go
func Serve(config config.Config) error {
	// load and build the project
	if err := site.Build(config); err != nil {
		return err
	}

	// serve target with file server
	fs := http.FileServer(http.Dir(config.TargetDir))
	http.Handle("/", fs)

	fmt.Println("server listening at http://localhost:4001/")
	return http.ListenAndServe(":4001", nil)
}
#+end_src

- improve for directory and html handling
  https://stackoverflow.com/a/57281956/993769
#+begin_src go
type HTMLFileSystem struct {
	dirFS http.Dir
}

func (htmlFS HTMLFileSystem) Open(name string) (http.File, error) {
	// Try name as supplied
	f, err := htmlFS.dirFS.Open(name)
	if os.IsNotExist(err) {
		// Not found, try with .html
		if f, err := htmlFS.dirFS.Open(name + ".html"); err == nil {
			return f, nil
		}
	}
	return f, err
}
#+end_src

#+begin_src go
fs := http.FileServer(HTMLFileSystem{http.Dir(config.TargetDir)})
http.Handle("/", fs)
#+end_src

*** Watching for changes
- fsnotify to trigger builds

*** Build optimizations
- optimization: worker pool

#+begin_src go
func (site *Site) Build() error {
	// clear previous target contents
	os.RemoveAll(site.Config.TargetDir)

	// walk the source directory, creating directories and files at the target dir
	return filepath.WalkDir(site.Config.SrcDir, func(path string, entry fs.DirEntry, err error) error {
		subpath, _ := filepath.Rel(site.Config.SrcDir, path)
		targetPath := filepath.Join(site.Config.TargetDir, subpath)

		// if it's a directory, just create the same at the target
		if entry.IsDir() {
			return os.MkdirAll(targetPath, FILE_RW_MODE)
		}

		// render or copy the source file at target
		return site.buildFile(path, targetPath)
	})
}
#+end_src

#+begin_src go
// Create a channel to send paths to build and a worker pool to handle them concurrently
func spawnBuildWorkers(site *site) (*sync.WaitGroup, chan string) {
	var wg sync.WaitGroup
	files := make(chan string, 20)

	for range runtime.NumCPU() {
		wg.Add(1)
		go func(files <-chan string) {
			defer wg.Done()
			for path := range files {
				site.buildFile(path)
			}
		}(files)
	}
	return &wg, files
}
#+end_src

#+begin_src go
func (site *site) build() error {
	// clear previous target contents
	os.RemoveAll(site.config.TargetDir)

	wg, files := spawnBuildWorkers(site)
	defer wg.Wait()
	defer close(files)

	// walk the source directory, creating directories and files at the target dir
	return filepath.WalkDir(site.config.SrcDir, func(path string, entry fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		subpath, _ := filepath.Rel(site.config.SrcDir, path)
		targetPath := filepath.Join(site.config.TargetDir, subpath)

		// if it's a directory, just create the same at the target
		if entry.IsDir() {
			return os.MkdirAll(targetPath, DIR_RWE_MODE)
		}
		// if it's a file (either static or template) send the path to a worker to build in target
		files <- path
		return nil
	})
}
#+end_src

- optimization: ln static files

*** Live reload

- intro sse (vs ws)
- naive implementation
- event broker
  - is this name right?

*** Refinements
- don't stop on errors
- ignore chmod and temp file events
- delay to prevent bursts
- make the js
