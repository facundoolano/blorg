---
title: Development notes
date: 2024-03-08
layout: post
lang: en
tags: [project]
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

Some miscelaneous notes from the jorge development process.

** Jekyll and Hugo

I'd been blogging with Jekyll for a few years now, first with a beautiful-jekyll [LINKS] fork on GitHub pages, later rewriting my site from scratch and hosting it in a VPS. I was generally satisfied with it; I was only attempting to replace it because a site generator was a [[file:why][good fit]] for my Go learning project. So I decided that for my project I was going to pick the subset of Jekyll functionality <I found most useful> and I would change only the specific things that didn't entirely fit my preferences or my blogging flow.

<Some of the things I decided to change:>
- Defaulting to serve everything in the root directory of the project. I preferred to use a separate ~src/~ directory instead, which saved me from explicitly excluding files from my git repo in the config.yml or prefixing them with a ~_~. This had the added benefit that the contents of the ~src/~ directory would be a faithful representation of the resulting website structure.
- Since my posts tend to have unique titles, I would exclude date information from the URLs by default, preferring, for instance, ~/blog/code-is-run-more-than-read~ over ~/2023-11-30-code-is-run-more-than-read/~. In addition to the cleaner URL, this would save me from renaming the file to adjust the date before publication. On a similar note, I would rely on front matter rather than a special directory to flag a post as draft.
- I would add native org-mode files support (but would keep Markdown as well).

Since I was set out to write a static site generator in Go, I had Hugo in my radar as a reference. I haven't used Hugo myself, but from skimming through the documentation I got the sense that it's more complex than Jekyll, certainly more than what I was aiming to build myself. I used it occasionally to a "second opinion" to compare to Jekyll's UX, and as a reference of for Go libraries (CLI, file watching, etc.).

One decision I took early on was to use liquid as a template language (like Jekyll) rather than the Go templates (like Hugo). I did this for two reasons:

- Apart from already being familiar with the liquid syntax, I had a Jekyll site that I wanted to use for testing and ultimately porting to jorge.
- I got the impression that the Go templates were a tool better suited for Go programmers than for users of programs built with Go. I suspected that going the Go templates route would have required extra work to make them user-friendly.

TODO: mention osteele/liquid and osteele/gojekyll

** CLI library

The Go standard library has reasonable support for building command-line programs ---not as flexible as Python's [[https://github.com/facundoolano/jorge/blob/HEAD/docs/src/blog/development-notes.org?plain=1#L33][argparse]] but good enough for most purposes. And, in fact, I implemented the entire jorge functionality out of [[https://gobyexample.com/command-line-arguments][basic]] [[https://gobyexample.com/command-line-flags][sample]] [[https://gobyexample.com/command-line-subcommands][programs]] from /Go by Example/. But before releasing the project I wanted to add some standard features like ~version~ and ~help~ flags, usage text and user-friendly errors; things better served by a specialized library.

I assumed, from previous experience in other languages, that all CLI libraries would be more or less equivalent, but the most popular ones for Go
turned out not to be flexible enough to accommodate the few usage patterns I had already implemented:
  - [[https://github.com/spf13/cobra][cobra]] commands implement a Run function that [[https://github.com/spf13/cobra/issues/67][doesn't return an error]], which would have required me to change add internal program exits when things other than CLI validations went wrong.
  - [[https://github.com/urfave/cli][urfave/cli]] produced required a lot of manual tweaking to produce usage text with the UX I was going for.
  - Both seemed to lack support for required/named positional arguments, so I couldn't express usages like ~jorge init <dir>~ or ~jorge post <title>~.

[[https://github.com/alecthomas/kong][kong]], on the other hand, allowed me to express my CLI very concisely and declaratively, preserving the code structure and UX I already had in place and removing validation logic. Once I translated my code to use kong, further refactor opportunities opened up.

** Smartypants

In my previous blogging setup, I wrote my posts in org and exported them to markdown before passing them to Jekyll, since this produced better-formed HTML documents. One of the benefits I got from this process, which I didn't know about until I started comparing the jorge output with my live blog, was
"smart quote" replacements: my jorge posts would render ~"Joe's Garage"~ where my website showed ~“Joe’s Garage”~. Once I started seeing those smart apostrophes I couldn't /un-see/ them, so I started researching how to have a similar replacement applied to jorge output files.


- The technique was [[https://daringfireball.net/projects/smartypants/][originally implemented]] in Perl by John Gruber (also author of [[https://daringfireball.net/projects/markdown/][Markdown]]); there's a very readable [[https://python-markdown.github.io/extensions/smarty/][Python port]], but not a general-purpose one for Golang. The algorithm is tricky and regexy-enough that I wouldn't dare trying to implement it myself, even if I somewhat understood the code.
- Most Markdown libraries do their own smart quotes replacement, including Golang's [[https://github.com/russross/blackfriday/blob/4ca8c28b21a883c59eb518036a3fe45a3f281463/smartypants.go][blackfriday]] and [[https://github.com/yuin/goldmark/blob/4f3074451eda8b06654d09415768726cf170985c/extension/typographer.go][goldmark]] (the one I was using in jorge). But relying on the Markdown exporter wasn't good enough for me; I wanted it to apply to org-mode sourced files as well, and even to standalone HTML files.
- I found out that there's an [[https://orgmode.org/manual/Export-Settings.html][org-export option]] for smart quotes, but it [[https://github.com/niklasfasching/go-org/issues/42][wasn't supported]] by go-org.
- Jekyll has a ~smartify~ filter (also [[https://github.com/osteele/gojekyll/blob/f1794a874890bfb601cae767a0cce15d672e9058/filters/smartify.go][available]] in gojekyll), but that required manual application by the user.
- The internal blackfriday logic was extracted into a [[https://github.com/kr/smartypants/][standalone Go package]], but after trying it I found it didn't work well when applied to the entire HTML document.

None of the options were usable as they were, but I was fixated on having this feature ---I didn't want the porting of my website to jorge feel as a downgrade in any way. What I ended up doing was copying the inner text replacement logic from the gojekyll filter ---since it was the shortest and simplest of the lot, even if potentially slow according to [[https://github.com/osteele/gojekyll/blob/f1794a874890bfb601cae767a0cce15d672e9058/filters/smartify.go#L3-L4][its comments]]--- tweaked it and applied it on my own HTML traversal code, making sure it was applied to the entire document except for some specific tags (which I took from the [[https://github.com/leohemsted/smartypants.py/blob/c46d26c559d706b6e0aa423190ab2d6edf1fdfcd/smartypants.py#L157][Python implementation]]): ~pre~, ~code~, ~script~, etc. The resulting code is [[https://github.com/facundoolano/jorge/blob/7df0be12c8cdc55015c03badca9944829bbf184f/markup/smartify.go][here]].

** CSS and Syntax Highlighting

- ignorant of website design, but not proudly.

- more generally, css is difficult
  - I thought I could get away with no graphic problems by cli and reusing my website styles
  - x browser bugs are still very annyoing (reminds me of the old js divergences)
  - https://stackoverflow.com/a/38347131/993769

- one does not simply enable syntax highlighting
  - too many combinations (light vs dark mode; inline vs code block; theme vs not theme; org vs md)
- es medio imposible de resolver satisfactoriamente el problema, o desactivas que respete la preferencia de dark mode o desactivas syntax highlighting para que el bloque respete esa preferencia
o, lo que hice en este caso, hacer que el sitio respete la preferencia pero los bloques de codigo no y que te queden fijos con un tema light o dark
- (lo ideal es tener dos css de syntax highlight y elegir uno u otro segun lo que prefiera el browser, pero es complicado de implementar genéricamente para un static site generator sin hardcodear un tema particular)
- There are several code rendering scenarios that need to be handled reasonably:
- light vs dark preferred color scheme
- pre code blocks vs inline code spans
- language set vs no language set
- markdown vs org rendering

Need to decide between:
- fixing the color scheme of the page + using one of chroma's themes
- supporting both light/dark and disabling syntax highlighting altogether
- supporting light/dark, picking a theme and patching it to render decently
  with both preferences (as done below, assuming chroma's github theme)
