---
title: Development notes
date: 2024-03-11
layout: post
lang: en
tags: [project]
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

Some miscelaneous notes from the jorge development process.

** Jekyll and Hugo

I'd been blogging with Jekyll for a few years now, first with a beautiful-jekyll [LINKS] fork on GitHub pages, later rewriting my site from scratch and hosting it in a VPS. I was generally satisfied with it; I was only attempting to replace it because a site generator was a [[file:why][good fit]] for my Go learning project. So I decided that for my project I was going to pick the subset of Jekyll functionality <I found most useful> and I would change only the specific things that didn't entirely fit my preferences or my blogging flow.

<Some of the things I decided to change:>
- Defaulting to serve everything in the root directory of the project. I preferred to use a separate ~src/~ directory instead, which saved me from explicitly excluding files from my git repo in the config.yml or prefixing them with a ~_~. This had the added benefit that the contents of the ~src/~ directory would be a faithful representation of the resulting website structure.
- Since my posts tend to have unique titles, I would exclude date information from the URLs by default, preferring, for instance, ~/blog/code-is-run-more-than-read~ over ~/2023-11-30-code-is-run-more-than-read/~. In addition to the cleaner URL, this would save me from renaming the file to adjust the date before publication. On a similar note, I would rely on front matter rather than a special directory to flag a post as draft.
- I would add native org-mode files support (but would keep Markdown as well).

Since I was set out to write a static site generator in Go, I had Hugo in my radar as a reference. I haven't used Hugo myself, but from skimming through the documentation I got the sense that it's more complex than Jekyll, certainly more than what I was aiming to build myself. I used it occasionally to a "second opinion" to compare to Jekyll's UX, and as a reference of for Go libraries (CLI, file watching, etc.).

One decision I took early on was to use liquid as a template language (like Jekyll) rather than the Go templates (like Hugo). I did this for two reasons:

- Apart from already being familiar with the liquid syntax, I had a Jekyll site that I wanted to use for testing and ultimately porting to jorge.
- I got the impression that the Go templates were a tool better suited for Go programmers than for users of programs built with Go. I suspected that going the Go templates route would have required extra work to make them user-friendly.

TODO: mention osteele/liquid and osteele/gojekyll

** CLI library

The Go standard library has reasonable support for building command-line programs ---not as flexible as Python's [[https://github.com/facundoolano/jorge/blob/HEAD/docs/src/blog/development-notes.org?plain=1#L33][argparse]] but good enough for most purposes. And, in fact, I implemented the entire jorge functionality out of [[https://gobyexample.com/command-line-arguments][basic]] [[https://gobyexample.com/command-line-flags][sample]] [[https://gobyexample.com/command-line-subcommands][programs]] from /Go by Example/. But before releasing the project I wanted to add some standard features like ~version~ and ~help~ flags, usage text and user-friendly errors; things better served by a specialized library.

I assumed, from previous experience in other languages, that all CLI libraries would be more or less equivalent, but the most popular ones for Go
turned out not to be flexible enough to accommodate the few usage patterns I had already implemented:
  - [[https://github.com/spf13/cobra][cobra]] commands implement a Run function that [[https://github.com/spf13/cobra/issues/67][doesn't return an error]], which would have required me to change add internal program exits when things other than CLI validations went wrong.
  - [[https://github.com/urfave/cli][urfave/cli]] produced required a lot of manual tweaking to produce usage text with the UX I was going for.
  - Both seemed to lack support for required/named positional arguments, so I couldn't express usages like ~jorge init <dir>~ or ~jorge post <title>~.

[[https://github.com/alecthomas/kong][kong]], on the other hand, allowed me to express my CLI very concisely and declaratively, preserving the code structure and UX I already had in place and removing validation logic. Once I translated my code to use kong, further refactor opportunities opened up.

** Smartypants

In my previous blogging setup, I wrote my posts in org and exported them to markdown before passing them to Jekyll, since this produced better-formed HTML documents. One of the benefits I got from this process, which I didn't know about until I started comparing the jorge output with my live blog, was
smart quote replacements: my jorge posts would render ~"Joe's Garage"~ where my website showed ~“Joe’s Garage”~. Once I started seeing those smart apostrophes I couldn't /un-see/ them, so I started researching how to have a similar replacement applied to jorge output files.


- The technique was [[https://daringfireball.net/projects/smartypants/][originally implemented]] in Perl by John Gruber (also author of [[https://daringfireball.net/projects/markdown/][Markdown]]); there's a very readable [[https://python-markdown.github.io/extensions/smarty/][Python port]], but not a general-purpose one for Golang. The algorithm is tricky and regexy-enough that I wouldn't dare trying to implement it myself, even if I somewhat understood the code.
- Most Markdown libraries do their own smart quotes replacement, including Golang's [[https://github.com/russross/blackfriday/blob/4ca8c28b21a883c59eb518036a3fe45a3f281463/smartypants.go][blackfriday]] and [[https://github.com/yuin/goldmark/blob/4f3074451eda8b06654d09415768726cf170985c/extension/typographer.go][goldmark]] (the one I was using in jorge). But relying on the Markdown exporter wasn't good enough for me; I wanted it to apply to org-mode sourced files as well, and even to standalone HTML files.
- I found out that there's an [[https://orgmode.org/manual/Export-Settings.html][org-export option]] for smart quotes, but it [[https://github.com/niklasfasching/go-org/issues/42][wasn't supported]] by go-org.
- Jekyll has a ~smartify~ filter (also [[https://github.com/osteele/gojekyll/blob/f1794a874890bfb601cae767a0cce15d672e9058/filters/smartify.go][available]] in gojekyll), but that required manual application by the user.
- The internal blackfriday logic was extracted into a [[https://github.com/kr/smartypants/][standalone Go package]], but after trying it I found it didn't work well when applied to the entire HTML document.

None of the options were usable as they were, but I was fixated on having this feature ---I didn't want the porting of my website to jorge feel as a downgrade in any way. What I ended up doing was copying the inner text replacement logic from the gojekyll filter ---since it was the shortest and simplest of the lot, even if potentially slow according to [[https://github.com/osteele/gojekyll/blob/f1794a874890bfb601cae767a0cce15d672e9058/filters/smartify.go#L3-L4][its comments]]--- tweaked it and applied it on my own HTML traversal code, making sure it was applied to the entire document except for some specific tags (which I took from the [[https://github.com/leohemsted/smartypants.py/blob/c46d26c559d706b6e0aa423190ab2d6edf1fdfcd/smartypants.py#L157][Python implementation]]): ~pre~, ~code~, ~script~, etc. The resulting code is [[https://github.com/facundoolano/jorge/blob/7df0be12c8cdc55015c03badca9944829bbf184f/markup/smartify.go][here]].

** CSS and Syntax Highlighting

One of [[file:why][the reasons]] why I decided to work on a CLI was that it would save me from building and polishing a graphical user interface. ~jorge init~ would generate a website from scratch, but my plan was to just reuse the styles from my personal website to avoid dealing with page layouts and CSS. That didn't go as planned; as soon as I started making minor changes to the default website, I found myself struggling between CSS syntax, browser quirks and my own limitations.

I can tell what I like and what I don't; I occasionally have ideas about how I'd like my site to look and I can usually Google my way into making it happen. But I am no designer, I haven't been trained to diagram, reason by principle or think holistically about design as I can with software ---not to mention keeping an eye on accessibility. I may get the site to look as I want but my CSS is brittle, any change may break things that were working before and what looks good in my machine may not in my cellphone or another browser.

HTML and CSS have come a long way in all these years, but every now and then I get war flashbacks from the jQuery days when I see that iOS Firefox shows a complete different thing than Firefox Desktop because it's just Safari under the hood, but then Safari Desktop's responsive mode doesn't necessarily match Safari iOS look either[fn:1].

One thing that got particularly hairy was trying to honor the browser preference for light/dark mode in the default website (through ~color-scheme~ and ~prefers-color-scheme~ media queries) while doing syntax highlighting of code blocks (with a library that's unaware of color preferences) and without forcing the same theme on all generated sites.

** Notas

[fn:1] [[https://stackoverflow.com/a/22417120/993769][This]] WebKit quirk was particularly annoying.
