---
title: Why?
date: 2024-02-27 14:35:56
layout: post
lang: en
tags: []
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

I'm set out to write a little static site generator, but why?

*** Why this project?
I wanted to learn the Go programming language, and my preferred way to learn a new language is to apply it on some open source project I'm interested in[fn:1].

*** Why Go?

In the past I studied new programming languages to broaden my horizons,
to add better, more sophisticated tools to my toolbox: new programming paradigms, concurrency models or type systems. Because I never used it in college and never needed it for work, and because it seemed to lack this "novelty factor", I never got around to trying Go.

But over the last few years, there has been a shift in how I assign value to technology. For all of the learning value of trying different things and broadening your horizons, I find the choice of sophisticated technology hard to justify for most real-world projects; in the long-term, the complexity they add outweighs the value they bring. And, in turn, I've became less and less enthusiastic about studying technology that I don't expect to ever use ---that I wouldn't dare to inflict to the real-world.

The very reason why I had avoided Go in the past, now compelled me to give it a try:
Go seemed to be an unpretentious, boring language ---and I mean that as [[https://mcfunley.com/choose-boring-technology][a compliment]]---, one that combined many of the good features I came to value (or miss) elsewhere:

- Easy to learn.
- Fast-enough.
- Garbage collected.
- Compiled to binary, making it easy to distribute and operate.
- With a static type system that's neither astonishing nor bureaucratic.
- With a powerful concurrency model that's built into the language rather than an afterthought.

That's the idea I had about the language, from reading about it but having never used it. If these presumptions turned out to be right, Go could become a reasonable default for many of my future projects ---and a good boring tech radar.

*** Why a command-line application?
Go is famously good for building server-side software, so that was the first space I turned to when thinking about projects to use it in. I briefly considered just following the Distributed Services with Go book, but I felt that would've yield a project I could hardly get enthusiastic about, one that I wouldn't see through completion. In fact, I suspected that any backend-only project would necessarily turn into a useless toy project I wouldn't care about. I needed something user-facing.

Could use Go to implement the backend of a web application? That would've made sense, but I was just [[https://olano.dev/2023-12-12-reclaiming-the-web-with-a-personal-reader/][coming out]] of developing a medium-sized web application[fn:2]. I knew too well that much of the effort would go into the UI, and I wanted a break from it.

What else, then? Other than servers, Go is known to be good at command-line applications. I enjoy working in CLI applications; they are a nice way to challenge myself with providing a good user experience without the struggle of graphical interfaces.

*** Why a static site generator?

** Notes

[fn:1] I did it before with [[https://github.com/facundoolano/advenjure][Clojure]] and [[https://github.com/facundoolano/rpg-cli][Rust]].

[fn:2] Incidentally, a project that I felt was ideal for Go if only I was already fluent with it.
