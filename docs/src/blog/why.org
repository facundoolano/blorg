---
title: Why?
date: 2024-02-27 14:35:56
layout: post
lang: en
tags: []
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

I set out to write a little static site generator, but why?

*** Why this project?
I wanted to learn the Go programming language, and my preferred way to learn a new language is to use it on some open source project[fn:1].

*** Why Go?

In the past I studied new programming languages to broaden my programming horizons,
to add better, more sophisticated tools to my toolbox: new paradigms, concurrency models, type systems. Because I never used it in college and never needed it for work, and because it seemed to lack this "novelty factor", I never got around to trying Go.

Over the last few years, there has been a shift in how I assign value to technology. Without underestimating the value of trying different things and broadening my horizons, I find the choice of sophisticated technology hard to justify for most real-world projects; in the long-term, the complexity they add outweighs the value they bring. In turn, I've became less and less enthusiastic about studying technology that I don't expect to ever apply ---that I wouldn't dare to inflict--- to the real-world.

The very reason why I had avoided Go in the past, now compelled me to give it a try:
Go seemed to be an unpretentious, boring language ---and I mean that as [[https://mcfunley.com/choose-boring-technology][a compliment]]---, one that combined many of the features I came to value (or miss) in other languages:

- Easy to learn.
- Fast enough.
- Garbage collected.
- Compiled to easy to distribute and operate binaries.
- With a static type system that's neither astonishing nor bureaucratic.
- With a powerful concurrency model that's built into the language rather than an afterthought.

That's the preconception I had about Go, having read about it but never used it. I wanted to spend some time with it because, if these presumptions turned out to be right, Go could become the obvious default for many of my future projects ---and an accurate boring tech radar.

*** Why a command-line application?
Go is famously good for building server-side software, so that was the first space I turned to when looking project ideas. I briefly considered following the [[https://pragprog.com/titles/tjgo/distributed-services-with-go/][/Distributed Services with Go/ book]], but I felt that would've yielded a project I wouldn't be enthusiastic about, one that I wouldn't see through completion. More generally, I suspected that any backend-only project would necessarily turn into a useless toy  I wouldn't care for. I needed something user-facing.

Could I use Go to implement the backend of a web application, instead? That would've made sense, but I was just [[https://olano.dev/2023-12-12-reclaiming-the-web-with-a-personal-reader/][coming out]] of working on a medium-sized web application[fn:2], and I knew too well that much of the effort in such a project would go into the frontend, and I wanted a break from that.

What else, then? Other than servers, Go is known to be good at command-line applications. I enjoy working on CLIs; they challenge me to design and reason about the user experience without having to struggle with a graphical interface. A CLI app sounded promising.

*** Why a static site generator?

I read somewhere that a blog is the ideal learning project for software developers: it can get as simple or as complex as you want, it exposes you to the entire web software stack, from server setup to UI design, and when it's done you are forced to write about something (most likely about setting up a blog).

That notion, projected into the CLI application space, yields a static site generator: a command-line tool to set up blogs. For a number of reasons, this seemed like the kind of project I was looking for:

- I knew that a static site generator was a feasible Go project because one of the most popular ones, Hugo, is written in Go.
- I knew it would be useful, because I'd been using one (Jekyll) for a few years.
- Moreover, since I had recently rewritten my blog from scratch, I knew what I wanted to reproduce and what I wanted to change from Jekyll, and I knew that, at least on a first look, it was about the project size I was looking for: not so small as to be boring, not so big as to get out of hand.

Assuming I would implement the local serving functionality (i.e. ~jekyll serve~), I could even go beyond the file manipulation tasks and touch on some of the concurrency and http features of Go.

Working on a site generator also meant that I could use the project to generate its own documentation and potentially to keep a development blog; to "dogfood", using the software myself as a I was building it.

-----

With that reasoning, I arrived to a project idea that seemed appropriate for my goals, feasible and interesting. This was enough to give me the first push to start working on it, but I still needed to outline the user interface and the project plan before a few more of the pieces fell into place. I'll get to that next time.

** Notes

[fn:1] I've done it before with [[https://github.com/facundoolano/advenjure][Clojure]] and [[https://github.com/facundoolano/rpg-cli][Rust]].

[fn:2] Incidentally, a project that I felt was ideal for Go, had I already been fluent with it.
