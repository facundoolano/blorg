---
title: Zen Mind, Google Intern's Mind
subtitle: Some notes about Go
date: 2024-03-27
layout: post
lang: en
tags: [golang, thoughts]
draft: true
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

jorge started as a Go learning project, so I'll wrap up this development blog with my thoughts of the language. I emphasize that these are first impressions more than truths or strong opinions, based in my experience of using it for about a month on small solo project. I had [[file:why][high expectations]] going in, and for the most part they were either confirmed or at least not disproven[fn:6].

*** Modules
I [[file:getting-started-with-go-and-emacs][started my tour]] by reading the tutorials in Go's website. Those showed how to write a [[https://go.dev/doc/tutorial/getting-started.html][Hello World program]], how to develop [[https://go.dev/doc/tutorial/create-module.html][an application and a library]] it depends on in parallel, and how to work on [[https://go.dev/doc/tutorial/workspaces][multi-module workspaces]]. In hindsight, that wasn't the most efficient way to get started, since those tutorials pulled me in the direction of writing multiple modules at a time, whereas I planned to work on a single binary project. The impression I got from them was that, perhaps for historical reasons, module management in Go is nuanced, at least compared with other languages I'm familiar with.

The first thing I had to adjust to was that a /module/ is more or less what I would call a /project/ in other languages. And what I would call a module elsewhere ---a namespace typically contained in a single file--- didn't have an exact equivalent: in Go each package is a collection of source files that share the same namespace.

One thing that Go nails just right in this department, probably better than every other language I used, is forcing imported identifiers to be qualified by its package name. This is supported in other languages but not mandatory, or default, or even convenient[fn:4]. Qualified imports make code much more readable because you can always tell where identifiers come from, how much you depend on an external module, etc. And it lets you remove redundancy from names, so you can mix ~io.Reader~ with ~bufio.Reader~ and ~strings.Reader~, instead of ~bufio.BufferReader~ and ~strings.StringReader~.

For similar reasons, I found it inconvenient that files within a package share a namespace, since it makes it less obvious where local identifiers are defined, when a namespace gets too large, etc. At first, the hygiene I carried from other languages made me want to write single-file packages, which introduced a lot of redundancies, etc. ~site/site.go~, ~config/config.go~, ~templates/templates.go~, etc.

*** Errors
I couldn't write a post like this one without commenting on Go's controversial error handling.
As a recap, errors are values in Go and, instead raising exceptions, functions have extra return values to signal error conditions. Whereas in Python one would do:

#+begin_src python
try:
    f = open('file.text')
except OSError as err:
    print("something went wrong", err)
#+end_src

In Go its:

#+begin_src go
file, err := os.Open(path)
if err != nil {
	fmt.Println("something went wrong", err)
}
#+end_src

Not that big of a difference.

- python rationale: 95% of the times you don't want to do local manipulation, you just want to bubble the error up handle it generically at a higher level, among other errors. so that's the default[fn:1]
- go's rationale: by assuming bubble up by default, you focus only in the happy path; 95% of the time there is no higher-level handling of errors, so programs are brittle.

Both views have their merit. The problem with go is that the boilerplate grows linearly with the amount of operations. As an example, here's a file copying function I had to introduce early in ~jorge~ development:

#+begin_src go
func copyFile(source string, target string) error {
	srcFile, err := os.Open(source)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	targetFile, err := os.Create(target)
	if err != nil {
		return err
	}
	defer targetFile.Close()

	_, err = io.Copy(targetFile, srcFile)
	if err != nil {
		return err
	}

	return targetFile.Sync()
}
#+end_src

The code doesn't make any decision about error-handling, just return them, and yet more than half is error-handling boilerplate. The equivalent python (ignoring the existence of ~shutil.copy~ that removes the need for this function), would get the same behavior without any error handling, or with single ~try/except~ clause if I wanted to do it explicitly.

I have used a fair bit of Rust before, so I was already bought into the idea of treating errors as values and always having to handle them explicitly. I agree that it forces you to give some thought at failure scenarios instead of just thinking in the happy path. The problem with Go is that it's lacking some syntax support for the error checking idioms, particularly that of just bubbling up the error[fn:2]. In the example above, Rust's question mark operator would remove all the boilerplate while still being explicit about error handling[fn:3]. It's not about typing less: the proliferation of ~if err != nil~ checks in Go hurts readability. When reading the code, sometimes it /is/ convenient to focus on the happy path to absorb what's going on.

- <Rob pike addresses this topic in article in the language website
  - basically says that if you are doing ~err != nil~ over and over, you probably aren't trying hard enough. Then demonstrates some creative ways to reduce error-handling boilerplate. Leaving aside the fact that the code structure doesn't always leave room for getting creative, I think something as mundane as error handling shouldn't require you to. What's more, that creativeness can result in going back to non obvious error handling, as is the case with the the ~bufio.Scanner~ example mentioned in the article.

There's another related blog post, which I found more thought-provoking: [[https://medium.com/@shazow/code-boilerplate-is-it-always-bad-934827efcfc7][Code boilerplate: Is it always bad?]]
  - suggests that maybe it's ok to have boilerplate, that the boilerplate highlights the substance of the operation in question
  - <for the sake of taking things as they are given and keeping a beginner's mind (see below) I'm willing to ignore my previous beliefs and accept that this error-checking discipline buys a reliability that outweighs its readability cost

https://go.dev/blog/errors-are-values
https://medium.com/@shazow/code-boilerplate-is-it-always-bad-934827efcfc7

TODO read https://jesseduffield.com/Questionable-Questionmarks/

*** Expressiveness

Expressiveness is a vaguely-defined and highly subjective quality for a programming language[fn:5]. I think about it as the distance the language puts between the abstract idea of the implementation a task (in pseudocode, perhaps) and its realization in working code. And I don't just mean distance in terms of lines of code ---how verbose the language is--- but the cognitive effort it takes to get there ---how much the language helps, how much it gets in the way.

<following up on the last remark: that the expressiveness of python maybe pulls you in the direction of putting the code as an end in itself, at its worst making you take choices that sacrifice reliability to keep it pretty.


*** Dependencies
*** Mindset

<I mentioned at the beginning of this devlog that my decisions to try Go was part of a journey of opting of choosing simple ---even boring--- tools to solve software problems.

Some of Go's design decision come across as arbitrary.

At best, pragmatic; at worst, inconsistent. At best, beginner-friendly; at worst, patronizing. At best, informed by real-world applications; at worst, tailor-made for Google's needs.

- The good: it's useful and reliable for the real-world applications. The bad: it can feel inconsistent, making it hard to derive intuitions or inform application design from first principles.
- The good: like Erlang, it's an engineering language, informed more by industry than academy. The bad: it can feel tailor-made to serve Google needs and even the preferences of its designers.
- The good: it's a beginner-friendly language. The bad: it can feel patronizing, as if it was designed for people not as smart as its authors [link PG].


** expressiveness
  - in python it tends to be very short distance. So I would say that Python is very expressive.
  - Rust tends to be in the opposite end, in my experience. The code may be succint in the end, but I frequently had to struggle to get to it, even for mundane tasks like iterating and transforming data structures.
  - I would say that Go is somewhere in the middle. it's usually lot more code than python but not hard to get there, never getting stuck in simple stuff
  - I should note that a lot of expressiveness is not necessarily a good thing: case in point the error handling discussion above (it may be better not to focus only in the happy path)

- the file open routine above may again be a good example.
  - mental model: cp f1 f2
  - https://stackoverflow.com/questions/2032149/optional-parameters-in-go
  https://groups.google.com/g/golang-nuts/c/-5MCaivW0qQ
  - i kind of miss default arguments (not to mention pythons great kwargs args)
    - instance of "we get to do magic stuff in the language but don't allow to do the same for language users"
    - contributes to the idea of googles style guidelines and do as told dont ask why
    - simplicity over expressiveness

- too much expressiveness can make you arrogant (?) enamored of your elegant terse code or your pristine type families or your <> class hierarchies

** dependencies (maybe part of the above?)

- it's hard to build an intuition around what should be a built-in function, what a struct method, what a standard library function, what you should write yourself or delegate to a third party library.

- batteries included but dumb data structures
  - things that should be methods are builtins or std package functions
  - apaprently common to resort to write common operations. maybe even more so in the past, judging by SO answers
  - I like the implications in terms of reduced dependencies
  - also like the API stability

- an example is with testing helpers
  - i like that the idiomatic thing is not to abuse dependencies and figure stuff out with stdlib
  - but I think it's just ridiculous that you don't even have an assert function in the stdlib
  - that, pairde with everything returning err would mean that mos tests would be 70% boilerplate
  - I saw a suggestion to code your own assert helpers, but seriously, that's hard to understand.
  - patronizing no asserts in faq

** philosophy / mindset

I went in expecting to find a boring language, in the good sense of the word [LINK].
this was true to the extent that go is an unpretentious language, it was designed to intentionally avoid unnecessary sophistication, it tries to be simpler<loose features> than the alternative of the time (c++, java)/
but it's not boring in the sense of always doing what you expect: it's not without its quirks and rough edges. It's simpler than Java and C++, yes, but I'm not sure it's necessarily a simple language [fn again, rich hickey]
- as the 100 go mistakes book puts it, it's easy to learn but hard to master https://100go.co/chapter-1/

- so you are forced to enter it with a humbling zen-like beginner's
  - zen mind: google intern's mind
    https://en.wikipedia.org/wiki/Shoshin

- since I'm learning this language out of humility, trying to accomplish things without sophistication, I try to accept things as they come without fighting them or trying to ask much why.
  - but I didn't imagine how that attitude would be helpful, even necessary, beyond the language choice.

- the fmt tool works as a good metaphor of the language design mindset.
  - yes, perhaps someone could make a strong case why spaces are marginally better than tabs, but even if tabs are the wrong choice, the benefits of removing the question altogether far outweight that marginal loss.
(that is, a language that makes as many decisions as possible for you will end up making you more productive even if those decisions are not the optimal for everyone)

** Notes
[fn:2] Go does indulge in syntax special cases for the sake of convenience or to work around language limitations. There are special rules to [[https://go.dev/doc/effective_go#redeclaration][redeclarate]] error return values, for instance. And I suppose the ~defer~ construct was introduced  specifically to keep resource management sane in the context of early error returns.

[fn:1] One funny aspect of Python's take on errors is that it seems to work against its own philosophy: "explicit is better than implicit" and (to a lesser degree, since runtime crashes aren't precisely quiet) "errors should never pass silently".

[fn:3] I'm not saying that Go should have union types or that it needs fixing, for that matter. Just that, despite its good intentions, I don't buy that errors as return values, without additional language support, are a strength of the language.

[fn:4] In Python, for instance, I need to write ~import feedi.parsers.rss as rss~ to get a similar effect. And since it's not the default, external code was not necessarily written with this usage pattern in mind.

[fn:5] Following Rich Hickey's distinction between simple and easy, expressiveness is more like the latter, not something you would justify technical decisions with.

[fn:6] TODO already talked about easy to learn and powerful concurrency
