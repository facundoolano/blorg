---
title: Project outline
date: 2024-02-29
layout: post
lang: en
tags: [project]
---
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: en

** User interface
When I'm toying with the idea for a new project, I start by picturing what it should look like from the perspective of the user: what the interface will be. For web applications, this means deciding what actions will I make available to users, what menus and buttons and what information I need to display on a given view; and then making some sketches to figure how to fit all that into a web page layout[fn:1].

For command-line applications it gets much easier: I just need to come up with the right list of program subcommands, some of its flags, and a couple of usage examples. As soon as I [[file:why][decided to work on a static site generator]], I narrowed the commands I needed to support down to four: ~init~, ~build~, ~serve~ and ~new~.

Below are some transcripts of my notebook, showing how I first imagined the commands would work (at this point I was calling the program ~golb~):

#+begin_src
$ golb init
$ golb init +now -rss -tags
$ golb init +now +rss +tags

$ golb init empty
$ golb init index
$ golb init blog
#+end_src

~init~ would be in charge of creating a new project with default files. I wanted this command to optionally "scaffold" a fully-featured website. The first way I pictured that was with an extensible system of flags (~+rss~ turns the RSS feed on, ~-tags~ disables the tag list page, etc.); later I considered using site profiles (a standalone ~index~, a full ~blog~, etc.). I eventually realized that both of those options would just confuse the user and over-complicate the implementation, so I left ~init~ without flags, always creating the same default site (including RSS, tag index, etc.). If users wanted an empty project instead they could just skip the ~init~ command altogether.

#+begin_src
$ golb serve [--drafts] [--future] [--no-reload]
$ golb build [--minify]
#+end_src

The ~serve~ command would run a local file server for previewing the website, while ~build~ would prepare the files for production. I wrote down some flags to help me picture what other features those commands would support (minifying the output, live reloading the browser upon file changes, etc.). I ended up implementing most of those extra options by default, but dropped the flags to keep the command-line interface simple.

#+begin_src
$ golb new
> title:
> tags:
$ golb new post
$ golb new note
#+end_src

The ~new~ command would be a helper to add new blog post pages, with some of the boilerplate (e.g. the date in the front matter) already filled in. I eventually renamed this subcommand to ~post~ and dropped most of its options.

** Project plan
Based on the CLI outline, I gave some thought to each of the subcommands and flags I planned to implement, trying to imagine, at a high-level, which operations they should consist of, what parts seemed easy or complicated to program, which ones I wasn't yet sure how I could tackle, what work I expected to delegate to third-party libraries, and where I suspected the "unknown-unknowns" of the project could be lurking. This exercise yielded a preliminary list of tasks, that I added to my project board:

#+begin_src
** Tasks

1. setup go and emacs
2. hello world
3. first stab at golb init
4. dummy golb build command
5. deploy to server
6. accept markdown as input
7. treat input files as templates
8. add some sort of layouts or template inheritance
9. parse input front matter
10. golb new to add a new blog post
11. tags
12. generate rss with build
13. --draft and --future support
14. some way of opting in and out of features on golb init
15. golb serve
16. post pagination
17. golb serve watch/autorefresh

** Nice to haves

1. minify output html and css
2. yaml data files
3. org-mode support
4. permalink override
5. add features after first initialization
6. optional per-tag rss feed
#+end_src

Some things to note from this list:
- This wasn't a strict plan I expected to follow but rather the necessary work I already identified, a guide to see what needed some thinking and another chance to validate my assumptions about the scope of the project.
- The initial order of the tasks was influenced by the user journey I imaged (e.g. start with ~golb init~), but as soon as I started working on the project I realized I should prioritize the "mission critical" features (~golb build~) then the most complex ones (~golb serve~).
- I captured some "nice to have" tasks that sounded interesting or fun to implement, but were not required for the project to make sense, and in some cases I didn't know if they were feasible. One such case was the org-mode support; as I'll explain in another post, learning that there already was a Go library to parse org-mode syntax would lead me to redefine the goals of the project.

** Some code
One nice quality of command-line programs is that their interfaces tend to easily translate into top layer of the program design, each subcommand offering a good spot to start coding.

Looking at the ~main.go~ file from [[https://github.com/facundoolano/jorge/commit/16cbf1d10ea890df216b74ad9231a1b70ad102c3#diff-2873f79a86c0d8b3335cd7731b0ecf7dd4301eb19a82ef7a1cba7589b5252261][one early commit]] shows much of the initial project plan already stubbed in the code:

#+begin_src go
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) < 2 {
		printAndExit()
	}

	switch os.Args[1] {

	case "init":
		// get working directory
		// default to .
		// if not exist, create directory
		// copy over default files
		fmt.Println("not implemented yet")
	case "build":
		// delete target if exist
		// create target dir
		// walk through files in src dir
		// copy them over to target
		// (later render templates and org)
		// (later minify)
		fmt.Println("not implemented yet")
	case "new":
		// prompt for title
		// slugify
		// fail if file already exist
		// create a new .org file with the slug
		// add front matter and org options
		fmt.Println("not implemented yet")
	case "serve":
		// build
		// serve target with file server
		// (later watch and live reload)
		fmt.Println("not implemented yet")
	default:
		printAndExit()
	}
}

func printAndExit() {
	// TODO print usage
	fmt.Println("expected a subcommand")
	os.Exit(1)
}
#+end_src


** Notes

[fn:1] Then hitting a bunch of walls trying to make that happen with CSS.
